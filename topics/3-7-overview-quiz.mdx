---
title: "Test your knwoledge"
date: 2024-01-25T15:32:14Z
lastmod: "2024-07-26"
draft: false
category: Scripts
layout: PostSimple
order: 7
parent: 3-overview
---

## Ex 1: Opcodes

Challenge your understanding of Bitcoin opcodes.

<Quiz
    questions={[
        {
            question:
                "Which opcode is used to duplicate the top item on the stack?",
            options: ["OP_DUP", "OP_SWAP", "OP_DROP", "OP_OVER"],
            correctAnswer: "OP_DUP",
            explanation:
                "OP_DUP duplicates the top item on the stack, making it useful for scripts that need to use the same data twice."
        },
        {
            question: "What is the primary purpose of OP_CHECKSIG?",
            options: [
                "To verify a digital signature",
                "To perform bitwise operations",
                "To manipulate stack items",
                "To push a constant value onto the stack"
            ],
            correctAnswer: "To verify a digital signature",
            explanation:
                "OP_CHECKSIG verifies that the signature is valid for the provided public key and message hash."
        },
        {
            question: "Which category does OP_SHA256 belong to?",
            options: ["Arithmetic", "Cryptographic", "Flow Control", "Stack"],
            correctAnswer: "Cryptographic",
            explanation:
                "OP_SHA256 is a cryptographic operation that applies the SHA-256 hash function to the top stack item."
        }
    ]}
/>

<div class="relative my-10 flex items-center">
    <div class="flex-grow h-0.5 bg-gradient-to-r from-transparent via-orange-300 to-gray-400"></div>
    <div class="mx-4 flex items-center">
        <div class="w-3 h-3 bg-gray-300 rounded-full"></div>
    </div>
    <div class="flex-grow h-0.5 bg-gradient-to-r from-gray-400 via-orange-300 to-transparent"></div>
</div>

## Ex 2: Locking and Unlocking

Letâ€™s see how well you understand the core concepts of locking and unlocking scripts, which are key to securing and spending Bitcoin transactions.

<Quiz
    questions={[
        {
            question: "What is another name for a Locking Script?",
            options: ["ScriptSig", "Witness", "ScriptPubKey", "OP_CHECKSIG"],
            correctAnswer: "ScriptPubKey",
            explanation:
                "The Locking Script is also known as a ScriptPubKey. It is used to define the conditions under which an output can be spent."
        },
        {
            question:
                "Which part of a Bitcoin transaction contains the Unlocking Script?",
            options: [
                "The input",
                "The output",
                "The transaction fee",
                "The coinbase"
            ],
            correctAnswer: "The input",
            explanation:
                "The Unlocking Script is provided for every input you want to spend in a transaction. It contains the necessary data to satisfy the conditions of the corresponding Locking Script."
        },
        {
            question:
                "In what order are the scripts executed when validating a transaction?",
            options: [
                "Locking Script first, then Unlocking Script",
                "Unlocking Script first, then Locking Script",
                "Both are executed simultaneously",
                "They are not executed during validation"
            ],
            correctAnswer: "Unlocking Script first, then Locking Script",
            explanation:
                "The Unlocking Script is executed first, and its result is then passed to the Locking Script. If the Locking Script is satisfied, the transaction is considered valid."
        },
        {
            question:
                "What happens if the Unlocking Script does not satisfy the Locking Script?",
            options: [
                "The transaction is added to the blockchain with a penalty",
                "The transaction is discarded and not added to the blockchain",
                "The transaction fee is increased",
                "The transaction is sent back for re-validation"
            ],
            correctAnswer:
                "The transaction is discarded and not added to the blockchain",
            explanation:
                "If the Unlocking Script does not satisfy the Locking Script, the transaction is considered invalid and is not added to the blockchain."
        },
        {
            question:
                "Which of the following is NOT true about a Locking Script?",
            options: [
                "It is placed on every output in a transaction",
                "It specifies the conditions for spending an output",
                "It is also known as a ScriptSig",
                "It can include cryptographic operations like OP_CHECKSIG"
            ],
            correctAnswer: "It is also known as a ScriptSig",
            explanation:
                "The Locking Script is not known as a ScriptSig; that term refers to the Unlocking Script. The Locking Script is known as a ScriptPubKey."
        }
    ]}
/>

<div class="relative my-10 flex items-center">
    <div class="flex-grow h-0.5 bg-gradient-to-r from-transparent via-orange-300 to-gray-400"></div>
    <div class="mx-4 flex items-center">
        <div class="w-3 h-3 bg-gray-300 rounded-full"></div>
    </div>
    <div class="flex-grow h-0.5 bg-gradient-to-r from-gray-400 via-orange-300 to-transparent"></div>
</div>

## Ex 3: Data

Implement the `OP_PUSHDATA2` logic in the `parseOpPushData` function.

1. Open `parseOpPushData.js`
2. Find the `TODO` comment for `OP_PUSHDATA2`
3. Implement logic to handle opcode 0x4d
4. Read 2 bytes for data length, then slice the data
5. Return formatted string like other `OP_PUSHDATA` operations

<SandpackComponent
  template="react"
  options={{
    externalResources: ["https://cdn.tailwindcss.com"],
    showLineNumbers: true,
    showInlineErrors: true,
    editorHeight: 800
  }}
  customSetup={{
    dependencies: {
      "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "framer-motion": "^6.0.0",
    "lucide-react": "latest"
    },
  }}
  files={{
    "/App.js": {
      code: `
import React, { useState, useEffect, useCallback } from 'react';
import { parseOpPushData } from './parseOpPushData';
import { testCases } from './testCases';
import { ChevronDown, ChevronUp, RefreshCw } from 'lucide-react';

const TestResult = ({ result, index }) => {
const [isExpanded, setIsExpanded] = useState(false);

return (

<div className="mb-4 bg-gray-800 rounded-lg shadow-md overflow-hidden border border-gray-700">
    <div
        className="p-4 cursor-pointer flex items-center justify-between"
        onClick={() => setIsExpanded(!isExpanded)}
    >
        <div className="flex items-center">
            <span
                className={
                    "text-lg font-semibold " +
                    (result.success ? "text-green-500" : "text-red-500")
                }
            >
                Test Case {index + 1}: {result.success ? "Pass" : "Fail"}
            </span>
        </div>
        <div className="flex items-center">
            <span className="text-sm text-gray-400 mr-2">{result.opcode}</span>
            {isExpanded ? (
                <ChevronUp className="text-gray-400" size={20} />
            ) : (
                <ChevronDown className="text-gray-400" size={20} />
            )}
        </div>
    </div>
    {isExpanded && (
        <div className="p-4 bg-gray-700">
            <div className="space-y-2 text-sm">
                <p className="text-gray-300">
                    Input:{" "}
                    <span className="font-mono text-orange-400">
                        {result.input}
                    </span>
                </p>
                <p className="text-gray-300">
                    Expected:{" "}
                    <span className="font-mono text-orange-400">
                        {result.expected}
                    </span>
                </p>
                <p className="text-gray-300">
                    Result:{" "}
                    <span className="font-mono text-orange-400">
                        {result.result}
                    </span>
                </p>
            </div>
        </div>
    )}
</div>
); };

export default function App() {
  const [results, setResults] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

const runTests = useCallback(async () => {
setIsLoading(true);
const newResults = await Promise.all(testCases.map(async ({ input, expected, opcode }) => {
try {
const result = await parseOpPushData(input);
return {
input,
expected,
result,
success: result === expected,
opcode,
};
} catch (error) {
return {
input,
expected,
result: 'Error: ' + error.message,
success: false,
opcode,
};
}
}));
setResults(newResults);
setIsLoading(false);
}, []);

useEffect(() => {
runTests();
}, [runTests]);

const passCount = results.filter(r => r.success).length;
const failCount = results.length - passCount;

return (

<div className='min-h-screen p-6 bg-gray-900'>
<div className='max-w-3xl mx-auto'>
<div className='flex justify-between items-center mb-6'>
<span className='text-2xl font-bold text-white'>
OP_PUSHDATA Test Results
</span>
<button 
            onClick={runTests} 
            className='bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded flex items-center'
          >
<RefreshCw className='mr-2' size={20} />
Run
</button>
</div>

        {isLoading ? (
          <div className='flex justify-center items-center h-64'>
            <div className='animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-orange-400'></div>
          </div>
        ) : (
          <>
            <div className='mb-6 p-4 bg-gray-800 border border-gray-700 rounded-lg'>
              <h2 className='font-bold text-white'>Test Summary</h2>
              <p className='text-gray-300 mt-2'>
                Total Tests: {results.length} |
                <span className='text-green-500 ml-2'>Passed: {passCount}</span> |
                <span className='text-red-500 ml-2'>Failed: {failCount}</span>
              </p>
            </div>
            {results.map((result, index) => (
              <TestResult key={index} result={result} index={index} />
            ))}
          </>
        )}
      </div>
    </div>

);
}
`    },
    "/parseOpPushData.js": {
      code:`
// **_ TODO: Implement OP_PUSHDATA2 logic here _**
// HIGHLIGHT: This is the section where you need to complete the code.
// You should read the next 2 bytes to get the length of the data to push onto the stack.
// Then slice the bytes buffer to get the actual data based on this length.

export const parseOpPushData = (hex) => {
  const bytes = Buffer.from(hex, 'hex');
  let offset = 0;

const firstByte = bytes[offset++];

if (firstByte <= 0x4b) {
// Direct push of 1-75 bytes
const data = bytes.slice(offset, offset + firstByte).toString('hex');
return "OP_PUSHDATA " + firstByte.toString(16).padStart(2, '0') + ' "' + data + '"';
} else if (firstByte === 0x4c) {
// OP_PUSHDATA1
const length = bytes[offset++];
const data = bytes.slice(offset, offset + length).toString('hex');
return "OP_PUSHDATA1 " + length.toString(16).padStart(2, '0') + ' "' + data + '"';
} else if (firstByte === 0x4d) {
// OP_PUSHDATA2
// TODO: Implement OP_PUSHDATA2 logic here
// HINT: You'll need to read 2 bytes to determine the length of the data.
// Then slice the bytes buffer to get the actual data based on this length.
throw new Error('OP_PUSHDATA2 not implemented');
} else if (firstByte === 0x4e) {
// OP_PUSHDATA4
const length = bytes.readUInt32LE(offset);
offset += 4;
const data = bytes.slice(offset, offset + length).toString('hex');
return "OP_PUSHDATA4 " + length.toString(16).padStart(8, '0') + ' "' + data + '"';
} else {
throw new Error('Invalid OP_PUSHDATA opcode');
}
};

const readVarInt = () => {
const firstByte = bytes[offset++];
if (firstByte < 0xfd) {
return firstByte;
} else if (firstByte === 0xfd) {
return bytes.readUInt16LE(offset);
} else if (firstByte === 0xfe) {
return bytes.readUInt32LE(offset);
} else {
return bytes.readBigUInt64LE(offset);
}
};

`,
      active: true,
    },
    "/testCases.js": {
      code: `
export const testCases = [
{ input: '4c0548656c6c6f', expected: 'OP_PUSHDATA1 05 "48656c6c6f"' },
//{ input: '03576f77', expected: 'OP_PUSHDATA 03 "576f77"' },
{ input: '4d0800004f70656e53656564', expected: 'OP_PUSHDATA2 0008 "4f70656e53656564"' },
{ input: '4e0c00000042697453747265616d', expected: 'OP_PUSHDATA4 0000000c "42697453747265616d"' },
];
`
}
}}
/>

<Hint
    title="Hints"
    hints={[
        "Use bytes.readUInt16LE(offset) for length",
        "Update offset after reading length",
        "Slice data: bytes.slice(offset, offset + length)"
    ]}
/>

<ExpandableAlert
  title="Solution"
  type="solution"
  expandable={true}
  initialLines={0}
>

```javascript
else if (firstByte === 0x4d) {
  const length = bytes.readUInt16LE(offset);
  offset += 2;
  const data = bytes.slice(offset, offset + length).toString('hex');
  return "OP_PUSHDATA2 " + length.toString(16).padStart(4, '0') + ' "' + data + '"';
}
```

</ExpandableAlert>

Implement the solution and run the tests to verify your code.

<div class="relative my-10 flex items-center">
    <div class="flex-grow h-0.5 bg-gradient-to-r from-transparent via-orange-300 to-gray-400"></div>
    <div class="mx-4 flex items-center">
        <div class="w-3 h-3 bg-gray-300 rounded-full"></div>
    </div>
    <div class="flex-grow h-0.5 bg-gradient-to-r from-gray-400 via-orange-300 to-transparent"></div>
</div>

## Ex 4: Script Success and Failure

This quiz will test your understanding of what makes a Bitcoin script valid or invalid, focusing on the conditions that lead to script success or failure.

<Quiz
    questions={[
        {
            question:
                "What determines the success or failure of a script after execution?",
            options: [
                "The presence of OP_CHECKSIG",
                "The final value left on top of the stack",
                "The number of elements left on the stack",
                "The order in which the operations were executed"
            ],
            correctAnswer: "The final value left on top of the stack",
            explanation:
                "After the script executes, the success or failure is determined by the final value on top of the stack. A non-zero value signifies success, while zero indicates failure."
        },
        {
            question:
                "Which of the following scenarios would result in a script being considered invalid?",
            options: [
                "The stack contains more than one element after execution",
                "The script completes execution naturally without errors",
                "A non-zero value remains on top of the stack",
                "The script runs to completion and leaves a single true value on the stack"
            ],
            correctAnswer:
                "The stack contains more than one element after execution",
            explanation:
                "If more than one element remains on the stack after execution, the script is considered invalid."
        },
        {
            question: "When does script execution naturally terminate?",
            options: [
                "When the script encounters a failure",
                "When the stack is empty",
                "When it runs to completion",
                "When the script reaches an OP_END operation"
            ],
            correctAnswer: "When it runs to completion",
            explanation:
                "Script execution naturally terminates when it reaches the end without encountering any errors."
        },
        {
            question:
                "Which of the following outcomes does NOT result in a failed script?",
            options: [
                "The stack is empty after execution",
                "The top stack element is OP_0",
                "The script aborts due to an invalid operation",
                "The script leaves a single true value on the stack"
            ],
            correctAnswer: "The script leaves a single true value on the stack",
            explanation:
                "If the script leaves a single true value on the stack, it is considered successful."
        },
        {
            question:
                "What does it mean if a script leaves an empty stack after execution?",
            options: [
                "The script was partially successful",
                "The script ran into an error and failed",
                "The script was valid",
                "The script must be re-executed"
            ],
            correctAnswer: "The script ran into an error and failed",
            explanation:
                "An empty stack after execution indicates that the script encountered an error and is considered invalid."
        }
    ]}
/>

<div class="relative my-10 flex items-center">
    <div class="flex-grow h-0.5 bg-gradient-to-r from-transparent via-orange-300 to-gray-400"></div>
    <div class="mx-4 flex items-center">
        <div class="w-3 h-3 bg-gray-300 rounded-full"></div>
    </div>
    <div class="flex-grow h-0.5 bg-gradient-to-r from-gray-400 via-orange-300 to-transparent"></div>
</div>

## Ex 5: Standard and non-standard transaction

Test your knowledge of standard and non-standard scripts, understanding the criteria that Bitcoin nodes use to relay or reject transactions.

<Quiz
    questions={[
        {
            question: "What defines a script as 'standard' in Bitcoin?",
            options: [
                "A script that is newly introduced and experimental",
                "A predefined and widely accepted transaction script",
                "A script that is complex and rarely used",
                "A script that has not been tested for security"
            ],
            correctAnswer:
                "A predefined and widely accepted transaction script",
            explanation:
                "Standard scripts are predefined, well-tested, and widely accepted by the Bitcoin network for their security and efficiency."
        },
        {
            question:
                "What happens to non-standard scripts in the Bitcoin network?",
            options: [
                "They are automatically relayed by all nodes",
                "They are relayed by some nodes but not by others",
                "They are not relayed by most nodes",
                "They are always mined immediately"
            ],
            correctAnswer: "They are not relayed by most nodes",
            explanation:
                "Non-standard scripts are not relayed by most nodes due to safety reasons, although they are still valid and can be mined."
        },
        {
            question:
                "Which script type is commonly used and recognized by nodes on the Bitcoin network?",
            options: [
                "Pay-to-PubKey (P2PK)",
                "Pay-to-PubKey-Hash (P2PKH)",
                "Pay-to-Script-Hash (P2SH)",
                "All of the above"
            ],
            correctAnswer: "All of the above",
            explanation:
                "P2PK, P2PKH, and P2SH are standard scripts that are widely recognized and accepted by nodes on the Bitcoin network."
        },
        {
            question:
                "How can a non-standard transaction be relayed and mined?",
            options: [
                "By wrapping the non-standard output scripts in P2SH/P2WSH",
                "By directly sending it to miners",
                "By creating a new standard template",
                "By including extra fees"
            ],
            correctAnswer:
                "By wrapping the non-standard output scripts in P2SH/P2WSH",
            explanation:
                "Wrapping non-standard output scripts in P2SH/P2WSH makes the transaction appear standard, allowing it to be relayed and mined."
        },
        {
            question:
                "Why are non-standard scripts generally not relayed by most nodes?",
            options: [
                "They are not secure",
                "They are experimental",
                "They deviate from commonly used templates and pose potential risks",
                "They have lower fees"
            ],
            correctAnswer:
                "They deviate from commonly used templates and pose potential risks",
            explanation:
                "Non-standard scripts deviate from commonly used templates, which is why they are not relayed by most nodes to maintain safety on the network."
        }
    ]}
/>

---
